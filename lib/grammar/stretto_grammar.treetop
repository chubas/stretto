require File.dirname(__FILE__) + '/grammar_helper'

require File.dirname(__FILE__) + '/value_grammar'
require File.dirname(__FILE__) + '/note_grammar'
require File.dirname(__FILE__) + '/chord_grammar'

require File.dirname(__FILE__) + '/channel_pressure_grammar'
require File.dirname(__FILE__) + '/controller_change_grammar'
require File.dirname(__FILE__) + '/instrument_grammar'
require File.dirname(__FILE__) + '/key_signature_grammar'
require File.dirname(__FILE__) + '/measure_grammar'
require File.dirname(__FILE__) + '/pitch_wheel_grammar'
require File.dirname(__FILE__) + '/polyphonic_pressure_grammar'
require File.dirname(__FILE__) + '/tempo_grammar'
require File.dirname(__FILE__) + '/timing_grammar'
require File.dirname(__FILE__) + '/variable_grammar'

grammar StrettoGrammar

  include ValueGrammar

  include ChannelPressureGrammar
  include ControllerChangeGrammar
  include InstrumentGrammar
  include KeySignatureGrammar
  include MeasureGrammar
  include PitchWheelGrammar
  include PolyphonicPressureGrammar
  include TempoGrammar
  include TimingGrammar
  include VariableGrammar

  rule notes
    space? head:music_element? more_elements:(space music_element)* space? <Stretto::Tokens::PatternToken>
  end

  rule music_element
    harmonic_chord / harmony_with_melody / single_music_element /
    measure / key_signature / instrument / voice / layer / tempo /
    pitch_wheel / channel_pressure / polyphonic_pressure / timing /
    controller_change / variable_definition
  end
  
  rule harmony_with_melody
    _first_element:single_music_element _other_elements:(_sep:[+_] _element:single_music_element)+ <Stretto::Tokens::HarmonyWithMelodyToken>
  end
  
  rule harmonic_chord
    # Force it to be greedy by putting a lookahead negative assertion.
    _first_element:chord_or_note _other_elements:('+' _element:chord_or_note)+ ![+_] <Stretto::Tokens::HarmonicChordToken>
  end

  rule chord_or_note
    chord / note
  end

  rule single_music_element
    chord / note / rest
  end

  rule chord
    note_string named_chord chord_inversions:chord_inversions? _duration:duration? attack_and_decay <Stretto::Tokens::ChordToken>
  end

  rule note
    note_string _duration:duration? attack_and_decay <Stretto::Tokens::NoteToken>
  end

  rule rest
    [Rr] _duration:duration? <Stretto::Tokens::RestToken>
  end

  rule note_string
    note_key _octave:octave? <Stretto::Tokens::NoteKeyOctaveAndAccidentalToken>
    /
    '[' _pitch:integer_or_variable_name ']' <Stretto::Tokens::NotePitchToken>
  end

  rule integer_or_variable_name
    integer {
      def is_numeric?
        true
      end
    }
    /
    variable_name {
      def is_numeric?
        false
      end
    }
  end

  rule named_chord
    # Make sure they're in reverse order, so 'maj6' is parsed before 'maj', for instance
    dom "7>5>9" / dom "7>5<9" / dom "7<5>9" / dom "7<5<9" / min maj "7" / maj "7>5" / maj "7<5" /
    dom "7>5" / dom "7<5" / maj "13" / min "13" / dom "13" / dom "11" / min "11" /
    [aA] [dD] [dD] "9" / dim "7" /
    min "9" / maj "9" / dom "9" / min "6" / maj "6" / sus "2" / sus "4" / min "7" / maj "7" /
    dom "7" / dim / [aA] [uU] [gG] / min / maj
  end

  rule min
    [mM] [iI] [nN]
  end

  rule dom
    [dD] [oO] [mM]
  end

  rule sus
    [sS] [uU] [sS]
  end

  rule dim
    [dD] [iI] [mM]
  end

  rule chord_inversions
    '^' note_string {
      def inversions
        0
      end

      def pivot_note
        note_string
      end
    }
    /
    '^'+ {
      def inversions
        text_value.size
      end

      def pivot_note
        nil
      end
    }
  end

  rule octave
    integer
  end

  rule duration
    _end_of_tie:tie? duration_string _start_of_tie:tie? <Stretto::Tokens::DurationToken>
  end

  rule duration_string
    _duration_character:[whqistxoWHQISTXO]+ _dots:('.'*) _tuplet:tuplet? {
      def duration_character
        _duration_character.text_value
      end

      def dots
        _dots.text_value.size
      end

      def tuplet
        _tuplet if _tuplet.text_value.present?
      end

      def value
        nil
      end
    }
    /
    '/' _value:variable_or_decimal {
      def duration_character
        nil
      end

      def dots
        0
      end

      def tuplet
        nil
      end

      def value
        _value
      end
    }
  end

  rule tuplet
    '*' _ratio:(_numerator:integer ':' _denominator:integer)? {
      def numerator
        _ratio._numerator.text_value if _ratio.text_value.present?
      end
      def denominator
        _ratio._denominator.text_value if _ratio.text_value.present?
      end
    }
  end

  rule tie
    '-'
  end

  rule attack_and_decay
    _attack:([aA] value:variable_or_integer)? _decay:([dD] value:variable_or_integer)? <Stretto::Tokens::AttackDecayToken>
  end

  rule voice
    kind:'V' __value:variable_or_integer <Stretto::Tokens::VoiceChangeToken>
  end

  rule layer
    kind:'L' __value:variable_or_integer <Stretto::Tokens::LayerChangeToken>
  end

  rule space
    [\s]+
  end

end
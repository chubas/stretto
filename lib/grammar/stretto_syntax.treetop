require File.dirname(__FILE__) + '/grammar_helper'

grammar StrettoSyntax

  rule notes
    space? head:music_element? more_elements:(space music_element)* space? <Stretto::Tokens::PatternToken>
  end

  rule music_element
    harmonic_chord / harmony_with_melody / single_music_element /
    measure_bar / key_signature / instrument / voice / layer / tempo /
    pitch_wheel / channel_pressure / polyphonic_pressure / timing_info /
    controller_change / variable_definition
  end
  
  rule harmony_with_melody
    _first_element:single_music_element _other_elements:(_sep:[+_] _element:single_music_element)+ <Stretto::Tokens::HarmonyWithMelodyToken>
  end
  
  rule harmonic_chord
    # Force it to be greedy by putting a lookahead negative assertion.
    _first_element:chord_or_note _other_elements:('+' _element:chord_or_note)+ ![+_] <Stretto::Tokens::HarmonicChordToken>
  end

  rule chord_or_note
    chord / note
  end

  rule single_music_element
    chord / note / rest
  end

  rule chord
    note_string named_chord chord_inversions:chord_inversions? _duration:duration? attack_and_decay <Stretto::Tokens::ChordToken>
  end

  rule note
    note_string _duration:duration? attack_and_decay <Stretto::Tokens::NoteToken>
  end

  rule rest
    'R' _duration:duration? <Stretto::Tokens::RestToken>
  end

  rule note_key
    key:[A-G] accidental:accidental?
  end

  rule note_string
    note_key _octave:octave? {
      def key
        note_key.key.text_value
      end

      def accidental
        note_key.accidental.text_value if note_key.accidental and note_key.accidental.text_value.present?
      end

      def value
        nil
      end

      def octave
        _octave.text_value if _octave and _octave.text_value.present?
      end
    }
    /
    "[" _value:(integer / variable_name) "]" {
      def accidental
        nil
      end

      def octave
        nil
      end

      def key
        nil
      end

      def value
        _value.text_value
      end
    }
  end

  rule accidental
    "##" / "#" / "bb" / "b" / "n"
  end

  rule named_chord
    # Make sure they're in reverse order, so 'maj6' is parsed before 'maj', for instance
    "dom7>5>9" / "dom7>5<9" / "dom7<5>9" / "dom7<5<9" / "minmaj7" / "maj7>5" / "maj7<5" /
    "dom7>5" / "dom7<5" / "maj13" / "min13" / "dom13" / "dom11" / "min11" / "add9" / "dim7" /
    "min9" / "maj9" / "dom9" / "min6" / "maj6" / "sus2" / "sus4" / "min7" / "maj7" /
    "dom7" / "dim" / "aug" / "min" / "maj"
  end

  rule chord_inversions
    '^' note_string {
      def inversions
        0
      end

      def pivot_note
        note_string
      end
    }
    /
    '^'+ {
      def inversions
        text_value.size
      end

      def pivot_note
        nil
      end
    }
  end

  rule octave
    integer
  end

  rule duration
    _end_of_tie:tie? duration_string _start_of_tie:tie? <Stretto::Tokens::DurationToken>
  end

  rule duration_string
    _duration_character:[whqistxo]+ _dots:('.'*) _tuplet:tuplet? {
      def duration_character
        _duration_character.text_value
      end

      def dots
        _dots.text_value.size
      end

      def tuplet
        _tuplet if _tuplet.text_value.present?
      end

      def decimal_value
        nil
      end
    }
    /
    '/' _decimal_value:variable_or_decimal {
      def duration_character
        nil
      end

      def dots
        0
      end

      def tuplet
        nil
      end

      def decimal_value
        _decimal_value
      end
    }
  end

  rule tuplet
    '*' _ratio:(_numerator:integer ':' _denominator:integer)? {
      def numerator
        _ratio._numerator.text_value if _ratio.text_value.present?
      end
      def denominator
        _ratio._denominator.text_value if _ratio.text_value.present?
      end
    }
  end

  rule tie
    '-'
  end

  rule attack_and_decay
    _attack:('a' value:variable_or_integer)? _decay:('d' value:variable_or_integer)? <Stretto::Tokens::AttackDecayToken>
  end

  rule key_signature
    'K' note_key scale:('maj' / 'min') <Stretto::Tokens::KeySignatureToken>
  end

  rule measure_bar
    '|' <Stretto::Tokens::MeasureToken>
  end

  rule instrument
    kind:'I' value:variable_or_integer <Stretto::Tokens::ModifierToken>
  end

  rule voice
    kind:'V' value:variable_or_integer <Stretto::Tokens::ModifierToken>
  end

  rule layer
    kind:'L' value:variable_or_integer <Stretto::Tokens::ModifierToken>
  end

  rule tempo
    kind:'T' value:variable_or_integer <Stretto::Tokens::ModifierToken>
  end

  rule pitch_wheel
    kind:'&' value:variable_or_integer <Stretto::Tokens::ModifierToken>
  end

  rule channel_pressure
    kind:'+' value:variable_or_integer <Stretto::Tokens::ModifierToken>
  end

  rule polyphonic_pressure
    '*' pitch:variable_or_integer ',' value:variable_or_integer <Stretto::Tokens::PolyphonicPressureToken>
  end

  rule controller_change
    'X' controller:variable_or_integer '=' value:variable_or_integer <Stretto::Tokens::ControllerChangeToken>
  end

  rule timing_info
    kind:'@' value:variable_or_integer <Stretto::Tokens::ModifierToken>
  end

  rule variable_definition
    # It can be set to a integer also, but decimal handles that case
    '$' variable_name '=' variable_or_decimal
  end

  rule variable_or_integer
    variable / integer
  end

  rule variable_or_decimal
    variable / decimal
  end

  rule integer
    "0" / [1-9] [0-9]*
  end

  rule decimal
    integer ('.' [0-9]+)?
  end

  rule variable
    '[' variable_name ']'
  end

  rule variable_name
    [A-Za-z_]+
  end

  rule space
    [\s]+
  end

end
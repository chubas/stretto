require File.join(File.dirname(__FILE__), 'tokens/note_string_token')
require File.join(File.dirname(__FILE__), 'tokens/duration_token')
require File.join(File.dirname(__FILE__), 'tokens/note_token')
require File.join(File.dirname(__FILE__), 'tokens/rest_token')
require File.join(File.dirname(__FILE__), 'tokens/chord_token')

grammar StrettoSyntax

  rule notes
    space? head:music_element? more_elements:(space music_element)* space? {
      def to_stretto
        unless head.text_value.empty?
          [head.to_stretto] + more_elements.elements.map{|element| element.music_element.to_stretto }
        else
          []
        end
      end
    }
  end

  rule music_element
    harmony_and_melody / single_music_element /
    measure_bar / key_signature / instrument / voice / layer / tempo /
    pitch_wheel / channel_pressure / polyphonic_pressure / timing_info /
    controller_change / variable_definition
  end

  rule harmony_and_melody
    single_music_element [_+] single_music_element ([_+] single_music_element)*
  end

  rule single_music_element
    chord / note / rest
  end

  rule chord
    note_string named_chord chord_inversions:chord_inversions? _duration:duration? attack_and_decay? <Stretto::Tokens::ChordToken>
  end

  rule note
    note_string _duration:duration? attack_and_decay? <Stretto::Tokens::NoteToken>
  end

  rule rest
    'R' duration:duration? <Stretto::Tokens::RestToken>
  end

  rule note_key
    key:[A-G] accidental:accidental?
  end

  rule note_string
    note_key _octave:octave? {
      def key
        note_key.key.text_value
      end

      def accidental
        note_key.accidental.text_value if note_key.accidental and note_key.accidental.text_value.present?
      end

      def value
        nil
      end

      def octave
        _octave.text_value if _octave and _octave.text_value.present?
      end
    }
    /
    "[" _value:(integer / variable_name) "]" {
      def accidental
        nil
      end

      def octave
        nil
      end

      def key
        nil
      end

      def value
        _value.text_value
      end
    }
  end

  rule accidental
    "##" / "#" / "bb" / "b" / "n"
  end

  rule named_chord
    # Make sure they're in reverse order, so 'maj6' is parsed before 'maj', for instance
    "dom7>5>9" / "dom7>5<9" / "dom7<5>9" / "dom7<5<9" / "minmaj7" / "maj7>5" / "maj7<5" /
    "dom7>5" / "dom7<5" / "maj13" / "min13" / "dom13" / "dom11" / "min11" / "add9" / "dim7" /
    "min9" / "maj9" / "dom9" / "min6" / "maj6" / "sus2" / "sus4" / "min7" / "maj7" /
    "dom7" / "dim" / "aug" / "min" / "maj"
  end

  rule chord_inversions
    '^' note_string {
      def inversions
        0
      end

      def pivot_note
        note_string
      end
    }
    /
    '^'+ {
      def inversions
        text_value.size
      end

      def pivot_note
        nil
      end
    }
  end

  rule octave
    integer
  end

  rule duration
    _start_tie:tie? duration_string _end_tie:tie? <Stretto::Tokens::DurationToken>
  end

  rule duration_string
    _duration_character:[whqistxo]+ _dots:('.'*) _tuplet:tuplet? {
      def duration_character
        _duration_character.text_value
      end

      def dots
        _dots
      end

      def tuplet
        _tuplet
      end

      def decimal_value
        nil
      end
    }
    /
    '/' _decimal_value:variable_or_decimal {
      def duration_character
        nil
      end

      def dots
        nil
      end

      def tuplet
        nil
      end

      def decimal_value
        _decimal_value
      end
    }
  end

  rule tuplet
    '*' (_numerator:integer ':' _denominator:integer)?
  end

  rule tie
    '-'
  end

  rule attack_and_decay
    ('a' variable_or_integer)? ('d' variable_or_integer)?
  end

  rule key_signature
    'K' note_key ('maj' / 'min')
  end

  rule measure_bar
    '|'
  end

  rule instrument
    'I' variable_or_integer
  end

  rule voice
    'V' variable_or_integer
  end

  rule layer
    'L' variable_or_integer
  end

  rule tempo
    'T' variable_or_integer
  end

  rule pitch_wheel
    '&' variable_or_integer
  end

  rule channel_pressure
    '+' variable_or_integer
  end

  rule polyphonic_pressure
    '*' variable_or_integer ',' variable_or_integer
  end

  rule controller_change
    'X' variable_or_integer '=' variable_or_integer
  end

  rule timing_info
    '@' variable_or_integer
  end

  rule variable_definition
    # It can be set to a integer also, but decimal handles that case
    '$' variable_name '=' variable_or_decimal
  end

  rule variable_or_integer
    variable / integer
  end

  rule variable_or_decimal
    variable / decimal
  end

  rule integer
    "0" / [1-9] [0-9]*
  end

  rule decimal
    integer ('.' [0-9]+)?
  end

  rule variable
    '[' variable_name ']'
  end

  rule variable_name
    [A-Za-z_]+
  end

  rule space
    [\s]+
  end

end